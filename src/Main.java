/**
 * Brinston R. Gonsalves
 * CS 782 HW 2
 * Implementing a Perceptron
 *
 *
 * The following code implements a Perceptron from Scratch. Run the main function in the Main class for trial.
 *
 * We check the accuracy of each Perceptron trained against each train file.
 * The results generated by the program are pasted below.
 * The Perceptron, initializes the weights randomly and so the values in the output may differ in every run.
 *
 * Perceptron{fileName='set1.train', weight1=2.039130963394898, weight2=0.017535540248593162, BIAS=1.0, biasWeight=-5.108720111990874, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.9655
 * Perceptron{fileName='set2.train', weight1=0.851658644893781, weight2=-0.24627701176642136, BIAS=1.0, biasWeight=-4.943312050288175, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.986
 * Perceptron{fileName='set3.train', weight1=2.6303019301814956, weight2=-0.27614974625725197, BIAS=1.0, biasWeight=-6.860236450788539, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.975
 * Perceptron{fileName='set4.train', weight1=1.0703056110517144, weight2=0.1653583995296119, BIAS=1.0, biasWeight=-3.6146583626760407, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.986
 * Perceptron{fileName='set5.train', weight1=0.3896658378167957, weight2=0.08314510298474265, BIAS=1.0, biasWeight=-2.143025792036566, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.9975
 * Perceptron{fileName='set6.train', weight1=0.29177121240854065, weight2=-0.02813667018052704, BIAS=1.0, biasWeight=-1.3231994637820663, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.999
 * Perceptron{fileName='set7.train', weight1=0.3501738334475507, weight2=0.16146754255580786, BIAS=1.0, biasWeight=-2.3859617486595033, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.946
 * Perceptron{fileName='set8.train', weight1=0.9056488313220188, weight2=0.043269597280407524, BIAS=1.0, biasWeight=-2.620482382210335, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.983
 * Perceptron{fileName='set9.train', weight1=0.5791675604510584, weight2=-0.1113080750496861, BIAS=1.0, biasWeight=-1.8432828818075133, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.986
 * Perceptron{fileName='set10.train', weight1=1.8215522708624101, weight2=0.17595338733717836, BIAS=1.0, biasWeight=-3.998937333162161, LEARNING_RATE=0.2}
 * Test Result (correct/total) : 0.9285
 *
 *
 * Here, while training we found that, each of the provided training set was linearly separable. On plotting this, thus we were sure that, a perceptron should
 * be sufficient to find the decision boundary and that we won't need any hidden layers for the provided dataset.
 *
 * Also, the solution found by the perceptron differs for each and every train set. This decision boundary will also slightly differ based on the initial value
 * of weights that we set randomly and the LEARNING_RATE. The change wont be significant though. And since the decision boundary differs, we also have accuracy
 * that slightly varies when tested against the test set.
 *
 *
 * The scatterplots for a sample run can be found in the outputImages folder.
 *
 *
 */

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.category.CategoryItemRenderer;
import org.jfree.chart.renderer.category.LineAndShapeRenderer;
import org.jfree.chart.renderer.category.ScatterRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.function.Function2D;
import org.jfree.data.function.LineFunction2D;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import java.util.List;

public class Main {

    public static void main(String[] args) {

        final String datasetFolder = "twoclassData";

        File allFiles[] = getAllFiles(datasetFolder);

        HashMap<Integer,File> trainFiles = getAllTrainFiles(allFiles);

        File testFile = getTestFile(allFiles);

/*

        System.out.println("Files : "+Arrays.toString(allFiles));
        System.out.println("Test : "+testFile);
        System.out.println("Train");
        for (int i :trainFiles.keySet()) {
            System.out.println(trainFiles.get(i));

        }
*/

/*

        for (Point point : points) {
            System.out.println(point.getPoint1()+"\t"+point.getPoint2()+"\t"+point.getClassType());
        }
*/

        List<Perceptron> perceptrons = new ArrayList<>();

        for (int i : trainFiles.keySet()) {
            Perceptron perceptron = new Perceptron(trainFiles.get(i).getName());
            List<Point> points = Point.getAllPoints(trainFiles.get(i));
            perceptron.trainOnFile(points);
            new Plotter("Boundary with Trained Perceptron : "+perceptron.getFileName()+"\nNumber of Iterations to train : "+perceptron.getNumOfIterations(),points,new Line(perceptron.getSlope(),perceptron.getIntercept()));
            perceptrons.add(perceptron);
        }


        for (Perceptron perceptron : perceptrons) {
            double result = perceptron.testOnFile(testFile);
            System.out.println(perceptron.toString());
            System.out.println("Test Result (correct/total) : "+result);
            new Plotter("Test File with Boundary of Perceptron : "+perceptron.getFileName()+"\nAccuracy : "+result,Point.getAllPoints(testFile), new Line(perceptron.getSlope(),perceptron.getIntercept()));

        }


    }

    private static File getTestFile(File[] allFiles) {
        for (File f : allFiles) {
            if (f.getName().endsWith("test")) {
                return f;
            }
        }

        return null;
    }

    private static HashMap<Integer, File> getAllTrainFiles(File[] allFiles) {
        HashMap<Integer,File> trainFiles = new HashMap<>();

        final String FILENAME_PREFIX = "set";
        final String TRAIN = "train";

        for (File f : allFiles) {
            if (f.getName().endsWith(TRAIN)) {
                int key = Integer.parseInt(f.getName().substring(FILENAME_PREFIX.length(),f.getName().indexOf(".")));
//                System.out.println(key);
//                System.out.println(f.getPath());
                trainFiles.put(key,f);

            }
        }
        return trainFiles;
    }

    private static File[] getAllFiles(String datasetFolder) {

        File parentFolder = new File(datasetFolder);

        File[] trainFiles = parentFolder.listFiles();

        return trainFiles;
    }
}


class Point {
    private double point1;
    private double point2;
    private int classType;

    public Point(double point1, double point2, int classType) {
        this.point1 = point1;
        this.point2 = point2;
        this.classType = classType;
    }

    public double getPoint1() {
        return point1;
    }

    public void setPoint1(double point1) {
        this.point1 = point1;
    }

    public double getPoint2() {
        return point2;
    }

    public void setPoint2(double point2) {
        this.point2 = point2;
    }

    public int getClassType() {
        return classType;
    }

    public void setClassType(int classType) {
        this.classType = classType;
    }


    public static List<Point> getAllPoints(File f) {

        List<Point> points = new ArrayList<>();

        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(f));

            String line = "";
            while ((line = bufferedReader.readLine())!= null) {
                String[] items = line.split(" ");
                points.add(new Point(Double.parseDouble(items[0]),Double.parseDouble(items[1]),Integer.parseInt(items[2].substring(0,items[2].indexOf(".")))==0?-1:1));
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            System.err.println("File not found : "+f.getName());
        } catch (IOException e) {
            e.printStackTrace();
            System.err.println("Error while reading File : "+f.getName());
        }
        return points;
    }
}





class Perceptron {

    private double weight1;
    private double weight2;
    final  double BIAS;
    private double biasWeight;
    final double LEARNING_RATE = 0.2;

    public int getNumOfIterations() {
        return numOfIterations;
    }

    public void setNumOfIterations(int numOfIterations) {
        this.numOfIterations = numOfIterations;
    }

    private int numOfIterations;


    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    private String fileName;

    public double getBiasWeight() {
        return biasWeight;
    }

    public void setBiasWeight(double biasWeight) {
        this.biasWeight = biasWeight;
    }


    public Perceptron(String name) {
        this.weight1 = (Math.random()*2)-1;
        this.weight2 = (Math.random()*2)-1;
        this.fileName = name;
        this.BIAS = 1;
        this.biasWeight = (Math.random()*2)-1; // BIAS turned off if = 0
        numOfIterations = 0;
    }

    public double getWeight1() {
        return weight1;
    }

    public void setWeight1(double weight1) {
        this.weight1 = weight1;
    }

    public double getWeight2() {
        return weight2;
    }

    public void setWeight2(double weight2) {
        this.weight2 = weight2;
    }

    public double getBIAS() {
        return BIAS;
    }



    public double getSumXiWi(Point point) {
        return point.getPoint1()*getWeight1()+point.getPoint2()*getWeight2()+ getBIAS() * getBiasWeight();
    }

    public int predict(Point point) {
        double value = getSumXiWi(point);
        if (value >= 0) {
            return 1;
        }
        else return -1;
    }

    public double getSlope() {
        return ((double)-1)*getWeight1()/getWeight2();
    }

    public double getIntercept() {
        return ((double)-1)*getBIAS()*getBiasWeight()/getWeight2();
    }


    public void trainOnFile(List<Point> points) {

        boolean flag = true;
        do {
            numOfIterations++;
            flag = true;
            for (Point point : points) {


                int prediction = predict(point);
                int realClass = point.getClassType();

//            System.out.println(prediction+"\t"+realClass);

                if (prediction != realClass) {

                    setBiasWeight(getBiasWeight() + (LEARNING_RATE * point.getClassType() * getBIAS()));
                    setWeight1(getWeight1() + (LEARNING_RATE * point.getClassType() * point.getPoint1()));
                    setWeight2(getWeight2() + (LEARNING_RATE * point.getClassType() * point.getPoint2()));
                    flag = false;
                }

            }
//            System.out.println("Final Weights : "+getBiasWeight()+"\t"+getWeight1()+"\t"+getWeight2());
        } while (flag == false);

    }


    public double testOnFile(File testFile) {
        List<Point> testPoints = Point.getAllPoints(testFile);

        int total = 0;
        int correct = 0;

        for (Point point : testPoints) {
            total++;
//            System.out.println(predict(point)+"\t"+point.getClassType());
            if (predict(point) == point.getClassType()) {
                correct++;
            }
        }

        return (double) correct/total;
    }

    @Override
    public String toString() {
        return "Perceptron{" +
                "weight1=" + weight1 +
                ", weight2=" + weight2 +
                ", BIAS=" + BIAS +
                ", biasWeight=" + biasWeight +
                ", LEARNING_RATE=" + LEARNING_RATE +
                ", numOfIterations=" + numOfIterations +
                ", fileName='" + fileName + '\'' +
                '}';
    }
}

class Line {
    private double slope;
    private double intercept;

    public Line(double slope, double intercept) {
        this.slope = slope;
        this.intercept = intercept;
    }

    public double getSlope() {
        return slope;
    }

    public double getIntercept() {
        return intercept;
    }
}

class Plotter extends JFrame {

    static int num = 1;

    public Plotter(String plotTitle, List<Point> points, Line line) {
        super("ScatterPlot");

//        System.out.println("Slope: "+line.getSlope());
//        System.out.println("Intercept: "+line.getIntercept());

        XYDataset linedata = DatasetUtilities.sampleFunction2D(new LineFunction2D(line.getIntercept(),line.getSlope()),-4,14,2, "BOUNDARY");



        XYSeriesCollection collection = new XYSeriesCollection();

        XYSeries series1 = new XYSeries("Class 1");
        XYSeries series2 = new XYSeries("Class 2");

        for (Point point : points) {

            if (point.getClassType() == 1) {
                series1.add(point.getPoint1(),point.getPoint2());
            }
            else {
                series2.add(point.getPoint1(),point.getPoint2());
            }

        }

        collection.addSeries(series1);
        collection.addSeries(series2);

        JFreeChart chart = ChartFactory.createXYLineChart(plotTitle,"X","Y",linedata);

        XYPlot plot = chart.getXYPlot();


        plot.setDataset(1,collection);

        ChartPanel panel = new ChartPanel(chart);


        try {
            File outputFile = new File("outputImages/" + num + ".png");
            outputFile.getParentFile().mkdirs();
            outputFile.createNewFile();
            ChartUtilities.saveChartAsPNG(outputFile,chart,800,400);

        } catch (IOException e) {
            e.printStackTrace();
        }

        num++;

        setContentPane(panel);




        this.setSize(800,400);
        this.setLocationRelativeTo(null);
        this.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
        this.setVisible(true);

    }


}